<<<
:sectnums:
== On-Chip Debugger (OCD)

.Work In Progress!
[IMPORTANT]
The on-chip debugger is still **work in progress** and **not operational yet**!

The NEORV32 Processor features an _on-chip debugger_ (OCD) implementing **execution-based debugging** that is compatible to the
"RISC-V debug spec. version 0.13.2". A copy of the spec is available in `docs/reference/riscv-debug-release.pdf`. The OCD provides the
following key features:

* JTAG test access port
* run-control of the CPU: halting, single-stepping and resuming
* accessing core registers (direct access to GPRs, indirect access to CSRs)
* indirect access to the whole processor address space
* compatible to the https://github.com/riscv/riscv-openocd[RISC-V port of OpenOCD]; pre-built binaries can be obtained for example from https://www.sifive.com/software[SiFive]

[NOTE]
The OCD requires additional resources for implementation and _might_ also increase the critical path resulting in less performance. If the OCD is
not really required for the _final_ implementation, it should be disabled and thus, discarded from implementation. In this
case all circuitry of the debugger is completely removed (no impact on area, energy or timing at all).

The NEORV32 on-chip debugger complex is based on four hardware modules:

.NEORV32 on-chip debugger complex
image::neorv32_ocd_complex.png[align=center]

[start=1]
. <<_debug_transport_module_dtm>> (`rtl/core/neorv32_debug_dtm.vhd`): External JTAG access tap to allow an external adapter to interface with the _debug module(DM)_
using the _debug module interface (dmi)_.
. <<_debug_module_dm>> (`rtl/core/neorv32_debug_tm.vhd`): Debugger control via memory-mapped registers that are accessed via the _dmi_.
. <<_debug_memory_dbmem>> (`rtl/core/neorv32_debug_dbmem.vhd`): This unit is a memory-mapped device that can be accesses by the CPU via
the processor-internal bus and by the DM via the _debug core interface (dci)_. the DBMEN provides an internal _data buffer_ for data
transfer from/to the DM, a _code ROM_ containing the "park loop, a _program buffer_ to execute small programs defined by the DM and a
_status register_ that is used to communicate _halt_, _resume_ and _execute_ requests/acknowledges from/to the DM.
. CPU <<_cpu_debug_mode>> extension (part of`rtl/core/neorv32_cpu_control.vhd`): This extension provides the "debug execution mode" which executes the "park loop"
code from the DBMEM. The mode also provides additional CSRs.

**Theory of Operation**

When debugging the system using the OCD, the CPU is brought into _debug mode_. In this state, the application-defined architectural state of the system is
"frozen" so the debugger can monitor and even modify it. While in debug mode, the CPU executes the "park loop" code from the _debug memory (DBMEM)_. This loop
implements an endless loop, in which the CPU polls the memory-mapped status registers that are controlled by the _debug module (DM)_.
These flags are used to trigger either the execution of the program buffer, which is also provided by the DM, or the resuming of the halted application.



<<<
// ####################################################################################################################
:sectnums:
=== Debug Transport Module (DTM)

.Work In Progress!
[WARNING]
TODO - JTAG IDCODE

The debug transport module (hardware module: `rtl/core/neorv32_debug_dtm.vhd`) provides a _JTAG TAP_ (test access port) that is used by an external debug system
to access the NEORV32 debug system.

[NOTE]
The actual JTAG clock signal is **not** used as primary clock. Instead it is used to synchronize
JTGA accesses, while all internal operations trigger on the system clock. Hence, no additional clock domain is required for integration of this module. However, this
reduces the maximal JTAG clock frequency as the JTAG clock (`jtag_tck_i`) has to be less than or equal to 1/4 of the system clock (`clk_i`) frequency.

[NOTE]
If the on-chip debugger is disabled (_ON_CHIP_DEBUGGER_EN_ = false) the JTAG serial input `jtag_tdi_i` is directly
connected to the JTAG serial output `jtag_tdo_o` to maintain the JTAG chain

[NOTE]
The DTM's instruction and data registers can be accessed using OpenOCDs `irscan` and `drscan` commands. The RISC-V port of OpenOCD
also provides low-level command (`riscv dmi_read` & `riscv dmi_write`) to access the _dmi_ debug module interface.

**TAP Registers**

JTAG access is conducted via the *instruction register* `IR`, which is 5 bit wide, and several *data registers* `DR` with different sizes. The data registers are accessed
by writing the according address to the instruction register. The following table shows the available data registers:

.JTAG TAP registers
[cols="^2,^2,^2,<8"]
[options="header",grid="rows"]
|=======================
| Address (via `IR`) | Name     | Size [bits] | Description
| `00001`            | `IDCODE` | 32          | identifier, configurable via the module's generics
| `10000`            | `DTMCS`  | 32          | debug transport module control and status register
| `10001`            | `DMI`    | 41          | debug module interface (_dmi_); 7-bit address, 32-bit read/write data, 2-bit operation (`00` = NOP; `10` = write; `01` = read)
| others             | `BYPASS` | 1           | default JTAG bypass register
|=======================

[INFO]
See the https://github.com/riscv/riscv-debug-spec[RISC-V debug specification] for more information regarding the data registers and operations.
A local copy can be found in `docs/reference`.



<<<
// ####################################################################################################################
:sectnums:
=== Debug Module (DM)

.Work In Progress!
[WARNING]
TODO





<<<
// ####################################################################################################################
:sectnums:
=== Debug Memory (DBMEM)

.Work In Progress!
[WARNING]
TODO - add park loop code

The debug memory provides a direct interfaces between the CPU and the DM. It includes a small ROM that contains the code for the "park loop", which is executed
when the CPU is _in_ debug mode. The DBMEM uses a total address space of 128 words ( = 512 bytes) divided into four sections of 32 words ( = 128 bytes) each.
Any CPU access within this address space will succeed. The program buffer only uses 4 effective words in this space but these words are mirrored
to fill up the whole 128 bytes of the section. The status register and the data buffer are also mirrored to fill their according section's
address space.

.Debug memory address map
[cols="^2,^2,^2,<8"]
[options="header",grid="rows"]
|=======================
| Base address | Name                | Actual size | Description
| `0xfffff800` | `dbmem_code_base_c` |    32 words | Code ROM for the "park loop" code
| `0xfffff880` | `dbmem_pbuf_base_c` |      4 word | Program buffer, provided by DM
| `0xfffff900` | `dbmem_data_base_c` |      1 word | Data buffer (`dm.data0`)
| `0xfffff980` | `dbmem_sreg_base_c` |      1 word | Control and status register
|=======================

When the CPU enters or re-enters (for example via `ebreak` in the DM's program buffer) debug mode, it jumps to `dbmem_code_base_c`,
which is the "normal entry point" for the park loop code. If an exception is encountered during debug mode, the CPU jumps to `dbmem_code_base_c + 4`,
which is the "exception entry point".

**Status Register**

The DBMEM status register provides a direct communication channel between the CPU executing the park loop and the controller of the DM.
Note that all bits that can be written by the CPU (acknowledge flags) cause a single-shot (1-cycle) signal to the DM and auto-clear. The bits that are
driven by the DM and are read-only to the CPU keep their state until the CPU acknowledges the according request.

.Debug memory - status register
[cols="^2,^2,^2,<8"]
[options="header",grid="rows"]
|=======================
| Bit | Name            | CPU access | Description
| 0   | `halt_ack`      | -/w        | Set by the CPU to indicate that the CPU is halted and iterating in the park loop
| 1   | `resume_req`    | r/-        | Set by the DM to tell the CPU to resume normal operation (leave parking loop and leave debug mode via `dret`)
| 2   | `resume_ack`    | -/w        | Set by the CPU to acknowledge that the CPU is now going to leave parking loop & debug mode
| 3   | `execute_req`   | r/-        | Set by the DM to tell the CPU to leave debug mode and execute the instructions from the program buffer; CPU will re-enter parking loop afterwards
| 4   | `execute_ack`   | -/w        | Set by the CPU to acknowledge that the CPU is now going to execute the program buffer
| 5   | `exception_ack` | -/w        | Set by the CPU to inform the DM that an exception occurred during execution of the park loop or during execution of the program buffer
|=======================



<<<
// ####################################################################################################################
:sectnums:
=== CPU Debug Mode

The NEORV32 CPU Debug Mode (part of `rtl/core/neorv32_cpu_control.vhd`) is compatible to the "RISC-V Debug Spec Version 0.13.2". It is
enabled/implemented by setting the CPU generic _CPU_EXTENSION_RISCV_DEBUG_ to "true" (done by setting processor generic _ON_CHIP_DEBUGGER_EN_).
It provides a new operation mode called "debug mode". When enabled, three additional CSRs are available (section <<_cpu_debug_mode_csrs>>) and
also the "return from debug mode" instruction `dret` is available when the CPU is "in" debug mode.

The CPU debug mode is entered when one of the following events appear:

[start=1]
. executing `ebreak` instruction (when `dcsr.ebreakm` is set and in machine mode OR when `dcsr.ebreaku` is set and in user mode)
. debug halt request from external DM (via CPU signal `db_halt_req_i`, high-active, triggering on rising-edge)
. finished executing of a single instruction while in single-step debugging mode (enabled via `dcsr.step`)

Whenever the CPU **enters debug mode** it performs the following operations:

* move `pc` to `dpcs`
* store the current privilege level to `dcsr.prv`
* set `dcrs.cause` according to the cause why debug mode is entered
* **no update** of `mtval`, `mcause`, `mtval` and `mstatus` CSRs
* load the address configured via the CPU _CPU_DEBUG_ADDR_ generic to the `pc` to jump to "debugger park loop" code in the debug memory

When the CPU **is in debug mode** the following things are important:

* while in debug mode, the CPU executes the parking loop and the program buffer provided by the DM if requested
* effective CPU privilege level is `machine` mode, PMP is not active
* if an exception occurs
  * if the exception was caused by any debug-mode entry action the CPU jumps to the _normal entry point_ ( = _CPU_DEBUG_ADDR_) of the park loop again (for example when executing `ebreak` in debug mode)
  * for all other exception sources the CPU jumps to the _exception entry point_ ( = _CPU_DEBUG_ADDR_ + 4) of the park loop again to signal an exception to the DM
* interrupts are masked - including NMIs; interrupts can be enabled _during the execution of single-stepped instructions_ when `dcsr.stepie` is set
* if the DM makes a resume request, the park loop exits and the CPU leaves debug mode

Whenever the CPU **leaves debug mode** the following things happen:

* set the current privilege level according to `dcsr.prv`
* restore `pc` from `dpcs`
* resume normal operation at `pc`


:sectnums:
==== CPU Debug Mode CSRs

[NOTE]
The debug-mode control and status registers (CSRs) are only accessible when the CPU is _in_ debug mode. If these CSRs are accessed
outside of debug mode (for example when in `machine` mode) an illegal instruction exception is raised.


:sectnums!:
===== **`dcsr`**

[cols="4,27,>7"]
[frame="topbot",grid="none"]
|======
| 0x7b0 | **Debug control and status register** | `dcsr`
3+| Reset value: 0x00000000
3+| The `dcsr` CSR is compatible to the RISC-V debug spec. It is used to configure debug mode and provides additional status information.
The following bits are implemented. The reaming bits are read-only and always read as zero.
|======

.Debug control and status register bits
[cols="^1,^2,^1,<8"]
[options="header",grid="rows"]
|=======================
| Bit   | Name [RISC-V] | R/W | Event
| 31:28 | `xdebugver` | r/- | always `0100` - indicates external debug support exists
| 15    | `ebereakm`  | r/w | `ebreak` instructions in `machine` mode _enter_ debug mode when set
| 12    | `ebereaku`  | r/w | `ebreak` instructions in `user` mode _enter_ debug mode when set
| 11    | `stepie`    | r/w | enable interrupts when in single-stepping mode
| 10    | `stopcount` | r/- | `0` - counters increment as usual
| 9     | `stoptime`  | r/- | `0` - timers increment as usual
| 8:6   | `cause`     | r/- | cause identifier - why was debug mode entered
| 4     | `mprven`    | r/- | `0` - `mstatus.mprv` is ignored when in debug mode
| 3     | `nmip`      | r/- | set when the non-maskable CPU/processor interrupt is pending
| 2     | `step`      | r/w | enable single-stepping when set
| 1:0   | `prv`       | r/w | CPU privilege level before/after debug mode
|=======================


:sectnums!:
===== **`dpc`**

[cols="4,27,>7"]
[frame="topbot",grid="none"]
|======
| 0x7b1 | **Debug program counter** | `dpc`
3+| Reset value: _UNDEFINED_
3+| The `dcsr` CSR is compatible to the RISC-V debug spec. It is used to store the current program counter when entering debug mode. The `dret`
instruction will return to `dpc`.
|======


:sectnums!:
===== **`dscratch0`**

[cols="4,27,>7"]
[frame="topbot",grid="none"]
|======
| 0x7b2 | **Debug scratch register 0** | `dscratch0`
3+| Reset value: _UNDEFINED_
3+| The `dscratch0` CSR is compatible to the RISC-V debug spec. It provides a general purpose scratch register.
|======

